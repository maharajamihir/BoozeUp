{"version":3,"sources":["../../src/paths/paths.ts"],"names":["ensureSlash","inputPath","needsSlash","hasSlash","endsWith","substr","length","getPossibleProjectRoot","fs","realpathSync","process","cwd","getEntryPoint","projectRoot","entryFiles","platforms","projectConfig","extensions","getEntryPointWithExtensions","exp","pkg","skipSDKVersionRequirement","entryPoint","entry","getFileWithExtensions","resolveFromSilentWithExtensions","main","Error","fileName","fromDirectory","moduleId","extension","modulePath","resolveFrom","silent","path","join","existsSync"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { getConfig } from '../Config';\nimport { ProjectConfig } from '../Config.types';\nimport { getManagedExtensions } from './extensions';\n\n// https://github.com/facebook/create-react-app/blob/9750738cce89a967cc71f28390daf5d4311b193c/packages/react-scripts/config/paths.js#L22\nexport function ensureSlash(inputPath: string, needsSlash: boolean): string {\n  const hasSlash = inputPath.endsWith('/');\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  } else if (!hasSlash && needsSlash) {\n    return `${inputPath}/`;\n  } else {\n    return inputPath;\n  }\n}\n\nexport function getPossibleProjectRoot(): string {\n  return fs.realpathSync(process.cwd());\n}\n\nexport function getEntryPoint(\n  projectRoot: string,\n  entryFiles: string[],\n  platforms: string[],\n  projectConfig?: ProjectConfig\n): string | null {\n  const extensions = getManagedExtensions(platforms);\n  return getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig);\n}\n\n// Used to resolve the main entry file for a project.\nexport function getEntryPointWithExtensions(\n  projectRoot: string,\n  entryFiles: string[],\n  extensions: string[],\n  projectConfig?: ProjectConfig\n): string {\n  const { exp, pkg } = projectConfig ?? getConfig(projectRoot, { skipSDKVersionRequirement: true });\n\n  // This will first look in the `app.json`s `expo.entryPoint` field for a potential main file.\n  // We check the Expo config first in case you want your project to start differently with Expo then in a standalone environment.\n  if (exp && exp.entryPoint && typeof exp.entryPoint === 'string') {\n    // If the field exists then we want to test it against every one of the supplied extensions\n    // to ensure the bundler resolves the same way.\n    let entry = getFileWithExtensions(projectRoot, exp.entryPoint, extensions);\n    if (!entry) {\n      // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n      entry = resolveFromSilentWithExtensions(projectRoot, exp.entryPoint, extensions);\n\n      // If it doesn't resolve then just return the entryPoint as-is. This makes\n      // it possible for people who have an unconventional setup (eg: multiple\n      // apps in monorepo with metro at root) to customize entry point without\n      // us imposing our assumptions.\n      if (!entry) {\n        return exp.entryPoint;\n      }\n    }\n    return entry;\n  } else if (pkg) {\n    // If the config doesn't define a custom entry then we want to look at the `package.json`s `main` field, and try again.\n    const { main } = pkg;\n    if (main && typeof main === 'string') {\n      // Testing the main field against all of the provided extensions - for legacy reasons we can't use node module resolution as the package.json allows you to pass in a file without a relative path and expect it as a relative path.\n      let entry = getFileWithExtensions(projectRoot, main, extensions);\n      if (!entry) {\n        // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n        entry = resolveFromSilentWithExtensions(projectRoot, main, extensions);\n        if (!entry)\n          throw new Error(\n            `Cannot resolve entry file: The \\`main\\` field defined in your \\`package.json\\` points to a non-existent path.`\n          );\n      }\n      return entry;\n    }\n  }\n\n  // Now we will start looking for a default entry point using the provided `entryFiles` argument.\n  // This will add support for create-react-app (src/index.js) and react-native-cli (index.js) which don't define a main.\n  for (const fileName of entryFiles) {\n    const entry = resolveFromSilentWithExtensions(projectRoot, fileName, extensions);\n    if (entry) return entry;\n  }\n\n  try {\n    // If none of the default files exist then we will attempt to use the main Expo entry point.\n    // This requires `expo` to be installed in the project to work as it will use `node_module/expo/AppEntry.js`\n    // Doing this enables us to create a bare minimum Expo project.\n\n    // TODO(Bacon): We may want to do a check against `./App` and `expo` in the `package.json` `dependencies` as we can more accurately ensure that the project is expo-min without needing the modules installed.\n    return resolveFrom(projectRoot, 'expo/AppEntry');\n  } catch {\n    throw new Error(\n      `The project entry file could not be resolved. Please either define it in the \\`package.json\\` (main), \\`app.json\\` (expo.entryPoint), create an \\`index.js\\`, or install the \\`expo\\` package.`\n    );\n  }\n}\n\n// Resolve from but with the ability to resolve like a bundler\nexport function resolveFromSilentWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  for (const extension of extensions) {\n    const modulePath = resolveFrom.silent(fromDirectory, `${moduleId}.${extension}`);\n    if (modulePath && modulePath.endsWith(extension)) {\n      return modulePath;\n    }\n  }\n  return resolveFrom.silent(fromDirectory, moduleId) || null;\n}\n\n// Statically attempt to resolve a module but with the ability to resolve like a bundler.\n// This won't use node module resolution.\nexport function getFileWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  const modulePath = path.join(fromDirectory, moduleId);\n  if (fs.existsSync(modulePath)) {\n    return modulePath;\n  }\n  for (const extension of extensions) {\n    const modulePath = path.join(fromDirectory, `${moduleId}.${extension}`);\n    if (fs.existsSync(modulePath)) {\n      return modulePath;\n    }\n  }\n  return null;\n}\n"],"file":"paths.js"}